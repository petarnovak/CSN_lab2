minus_log_like_zeta <- function(gamma){
length(x) * log(zeta(gamma)) + gamma * sum(log(x))
}
# Zeta (gamma=2) distribution
minus_log_like_zeta2 <- function(){
mle <- length(x) * log(pi^2/6) + 2 * sum(log(x))
return(mle)
}
# Right-truncated zeta distribution
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
x <- read.table(file, header = FALSE)$V1
mle_geo <- mle(minus_log_like_geo,
start = list(p = lang.df$"N/M"[i]),
method = "L-BFGS-B",
lower = c(0.0000001),
upper = c(0.9999999))
mle_pois <- mle(minus_log_like_pois,
start = list(lambda = lang.df$"M/N"[i]),
method = "L-BFGS-B",
lower = c(1.0000001))
mle_zeta <- mle(minus_log_like_zeta,
start = list(gamma = 2),
method = "L-BFGS-B",
lower = c(1.0000001))
#This gives error for some languages
#mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
#                      start = list(gamma = 2, h_max = max(x)),
#                      method = "L-BFGS-B",
#                      lower = c(1.0000001, 1),
#                      upper = c(Inf, max(x)+1))
# 4: Finding the best models
best_p_geo <- attributes(summary(mle_geo))$coef[1]
best_lambda_pois <- attributes(summary(mle_pois))$coef[1]
best_gamma_zeta <- attributes(summary(mle_zeta))$coef[1]
#best_gamma_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[1]
#best_h_max_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[2]
param.df <- rbind(param.df,data.frame(language, best_lambda_pois, best_p_geo, best_gamma_zeta))
# 5: Best model selection
get_AIC <- function(m2logL,K,N){
m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
AIC_list <- c()
AIC_list[1] <- get_AIC(attributes(summary(mle_geo))$m2logL,1,length(x))
AIC_list[2] <- get_AIC(attributes(summary(mle_pois))$m2logL,1,length(x))
AIC_list[3] <- get_AIC(attributes(summary(mle_zeta))$m2logL,1,length(x))
mle_zeta2 <- 2*minus_log_like_zeta2()
AIC_list[4] <- get_AIC(mle_zeta2,0,length(x))
#AIC_zeta_trunc <- get_AIC(attributes(summary(mle_zeta_trunc))$m2logL,2,length(x))
best_AIC <- min(AIC_list)
AIC_list <- AIC_list-best_AIC
AIC.df <- rbind(AIC.df,AIC_list)
return(list(param.df, AIC.df))
}
param.df <- data.frame() #table with most likely parameters
AIC.df <- data.frame()
for (i in 1:nrow(source)){
tables <- mle_calc(i, source$language[i], source$file[i],param.df,AIC.df)
param.df <- tables[[1]]
AIC.df <- tables[[2]]
}
colnames(param.df) <- c("Language", "lambda", "p", "gamma_1")
param.df
AIC.df
a <- c()
a[2]<-2
a
min(a)
mle_calc <- function(i,language,file,param.df,AIC.df){
# Geometric distribution
minus_log_like_geo <- function(p){
-(sum(x)-length(x)) * log(1-p) - length(x) * log(p)
}
# Poisson distribution
minus_log_like_pois <- function(lambda){
C <- 0
for (i in 1:length(x)) {
C = C + sum(log(2:x[i]))
}
- sum(x) * log(lambda) + length(x) * (lambda + log(1-exp(1)^(-lambda))) + C
}
# Zeta distribution
minus_log_like_zeta <- function(gamma){
length(x) * log(zeta(gamma)) + gamma * sum(log(x))
}
# Zeta (gamma=2) distribution
minus_log_like_zeta2 <- function(){
mle <- length(x) * log(pi^2/6) + 2 * sum(log(x))
return(mle)
}
# Right-truncated zeta distribution
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
x <- read.table(file, header = FALSE)$V1
mle_geo <- mle(minus_log_like_geo,
start = list(p = lang.df$"N/M"[i]),
method = "L-BFGS-B",
lower = c(0.0000001),
upper = c(0.9999999))
mle_pois <- mle(minus_log_like_pois,
start = list(lambda = lang.df$"M/N"[i]),
method = "L-BFGS-B",
lower = c(1.0000001))
mle_zeta <- mle(minus_log_like_zeta,
start = list(gamma = 2),
method = "L-BFGS-B",
lower = c(1.0000001))
#This gives error for some languages
#mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
#                      start = list(gamma = 2, h_max = max(x)),
#                      method = "L-BFGS-B",
#                      lower = c(1.0000001, 1),
#                      upper = c(Inf, max(x)+1))
# 4: Finding the best models
best_p_geo <- attributes(summary(mle_geo))$coef[1]
best_lambda_pois <- attributes(summary(mle_pois))$coef[1]
best_gamma_zeta <- attributes(summary(mle_zeta))$coef[1]
#best_gamma_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[1]
#best_h_max_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[2]
param.df <- rbind(param.df,data.frame(language, best_lambda_pois, best_p_geo, best_gamma_zeta))
# 5: Best model selection
get_AIC <- function(m2logL,K,N){
m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
AIC_list <- c()
AIC_list[1] <- get_AIC(attributes(summary(mle_geo))$m2logL,1,length(x))
AIC_list[2] <- get_AIC(attributes(summary(mle_pois))$m2logL,1,length(x))
AIC_list[3] <- get_AIC(attributes(summary(mle_zeta))$m2logL,1,length(x))
mle_zeta2 <- 2*minus_log_like_zeta2()
AIC_list[4] <- get_AIC(mle_zeta2,0,length(x))
#AIC_zeta_trunc <- get_AIC(attributes(summary(mle_zeta_trunc))$m2logL,2,length(x))
best_AIC <- min(AIC_list)
AIC_list <- AIC_list-best_AIC
AIC.df <- rbind(AIC.df,data.frama(language,AIC_list))
return(list(param.df, AIC.df))
}
param.df <- data.frame() #table with most likely parameters
AIC.df <- data.frame()
for (i in 1:nrow(source)){
tables <- mle_calc(i, source$language[i], source$file[i],param.df,AIC.df)
param.df <- tables[[1]]
AIC.df <- tables[[2]]
}
AIC.df <- rbind(AIC.df,data.frame(language,AIC_list))
return(list(param.df, AIC.df))
mle_calc <- function(i,language,file,param.df,AIC.df){
# Geometric distribution
minus_log_like_geo <- function(p){
-(sum(x)-length(x)) * log(1-p) - length(x) * log(p)
}
# Poisson distribution
minus_log_like_pois <- function(lambda){
C <- 0
for (i in 1:length(x)) {
C = C + sum(log(2:x[i]))
}
- sum(x) * log(lambda) + length(x) * (lambda + log(1-exp(1)^(-lambda))) + C
}
# Zeta distribution
minus_log_like_zeta <- function(gamma){
length(x) * log(zeta(gamma)) + gamma * sum(log(x))
}
# Zeta (gamma=2) distribution
minus_log_like_zeta2 <- function(){
mle <- length(x) * log(pi^2/6) + 2 * sum(log(x))
return(mle)
}
# Right-truncated zeta distribution
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
x <- read.table(file, header = FALSE)$V1
mle_geo <- mle(minus_log_like_geo,
start = list(p = lang.df$"N/M"[i]),
method = "L-BFGS-B",
lower = c(0.0000001),
upper = c(0.9999999))
mle_pois <- mle(minus_log_like_pois,
start = list(lambda = lang.df$"M/N"[i]),
method = "L-BFGS-B",
lower = c(1.0000001))
mle_zeta <- mle(minus_log_like_zeta,
start = list(gamma = 2),
method = "L-BFGS-B",
lower = c(1.0000001))
#This gives error for some languages
#mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
#                      start = list(gamma = 2, h_max = max(x)),
#                      method = "L-BFGS-B",
#                      lower = c(1.0000001, 1),
#                      upper = c(Inf, max(x)+1))
# 4: Finding the best models
best_p_geo <- attributes(summary(mle_geo))$coef[1]
best_lambda_pois <- attributes(summary(mle_pois))$coef[1]
best_gamma_zeta <- attributes(summary(mle_zeta))$coef[1]
#best_gamma_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[1]
#best_h_max_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[2]
param.df <- rbind(param.df,data.frame(language, best_lambda_pois, best_p_geo, best_gamma_zeta))
# 5: Best model selection
get_AIC <- function(m2logL,K,N){
m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
AIC_list <- c()
AIC_list[1] <- get_AIC(attributes(summary(mle_geo))$m2logL,1,length(x))
AIC_list[2] <- get_AIC(attributes(summary(mle_pois))$m2logL,1,length(x))
AIC_list[3] <- get_AIC(attributes(summary(mle_zeta))$m2logL,1,length(x))
mle_zeta2 <- 2*minus_log_like_zeta2()
AIC_list[4] <- get_AIC(mle_zeta2,0,length(x))
#AIC_zeta_trunc <- get_AIC(attributes(summary(mle_zeta_trunc))$m2logL,2,length(x))
best_AIC <- min(AIC_list)
AIC_list <- AIC_list-best_AIC
AIC.df <- rbind(AIC.df,data.frame(language,AIC_list))
return(list(param.df, AIC.df))
}
param.df <- data.frame() #table with most likely parameters
AIC.df <- data.frame()
for (i in 1:nrow(source)){
tables <- mle_calc(i, source$language[i], source$file[i],param.df,AIC.df)
param.df <- tables[[1]]
AIC.df <- tables[[2]]
}
colnames(param.df) <- c("Language", "lambda", "p", "gamma_1")
colnames(AIC.df) <- c("Language", "lambda", "p", "gamma_1")
colnames(AIC.df) <- c("Language", "1", "2", "3", "4")
AIC.df
a <- data.frame(1,2,3)
a
d<- rbind(a,data.frame(b,c))
d<- rbind(a,b,c)
d
a <- data.frame()
b<- "Ciao"
c<- c(1,2,3)
d<- rbind(a,b,c)
d
a <- data.frame()
b <- "Ciao"
c <- c(1,2,3)
d <- rbind(a,b,c)
d
d <- rbind(a,data.frame(b,c))
d
a <- data.frame()
b <- "Ciao"
c <- c(1,2,3)
d <- rbind(a,rbind(b,c))
d
rbind(b,c)
hbind(b,c)
lbind(b,c)
rbind(b,c)
bind(b,c)
rbind(b,c)
d <- rbind(a,rbind(b,t(c)))
d
d <- rbind(a,data.frame(b,t(c)))
d
mle_calc <- function(i,language,file,param.df,AIC.df){
# Geometric distribution
minus_log_like_geo <- function(p){
-(sum(x)-length(x)) * log(1-p) - length(x) * log(p)
}
# Poisson distribution
minus_log_like_pois <- function(lambda){
C <- 0
for (i in 1:length(x)) {
C = C + sum(log(2:x[i]))
}
- sum(x) * log(lambda) + length(x) * (lambda + log(1-exp(1)^(-lambda))) + C
}
# Zeta distribution
minus_log_like_zeta <- function(gamma){
length(x) * log(zeta(gamma)) + gamma * sum(log(x))
}
# Zeta (gamma=2) distribution
minus_log_like_zeta2 <- function(){
mle <- length(x) * log(pi^2/6) + 2 * sum(log(x))
return(mle)
}
# Right-truncated zeta distribution
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
x <- read.table(file, header = FALSE)$V1
mle_geo <- mle(minus_log_like_geo,
start = list(p = lang.df$"N/M"[i]),
method = "L-BFGS-B",
lower = c(0.0000001),
upper = c(0.9999999))
mle_pois <- mle(minus_log_like_pois,
start = list(lambda = lang.df$"M/N"[i]),
method = "L-BFGS-B",
lower = c(1.0000001))
mle_zeta <- mle(minus_log_like_zeta,
start = list(gamma = 2),
method = "L-BFGS-B",
lower = c(1.0000001))
#This gives error for some languages
#mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
#                      start = list(gamma = 2, h_max = max(x)),
#                      method = "L-BFGS-B",
#                      lower = c(1.0000001, 1),
#                      upper = c(Inf, max(x)+1))
# 4: Finding the best models
best_p_geo <- attributes(summary(mle_geo))$coef[1]
best_lambda_pois <- attributes(summary(mle_pois))$coef[1]
best_gamma_zeta <- attributes(summary(mle_zeta))$coef[1]
#best_gamma_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[1]
#best_h_max_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[2]
param.df <- rbind(param.df,data.frame(language, best_lambda_pois, best_p_geo, best_gamma_zeta))
# 5: Best model selection
get_AIC <- function(m2logL,K,N){
m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
AIC_list <- c()
AIC_list[1] <- get_AIC(attributes(summary(mle_geo))$m2logL,1,length(x))
AIC_list[2] <- get_AIC(attributes(summary(mle_pois))$m2logL,1,length(x))
AIC_list[3] <- get_AIC(attributes(summary(mle_zeta))$m2logL,1,length(x))
mle_zeta2 <- 2*minus_log_like_zeta2()
AIC_list[4] <- get_AIC(mle_zeta2,0,length(x))
#AIC_zeta_trunc <- get_AIC(attributes(summary(mle_zeta_trunc))$m2logL,2,length(x))
best_AIC <- min(AIC_list)
AIC_list <- AIC_list-best_AIC
AIC.df <- rbind(AIC.df,data.frame(language,t(AIC_list)))
return(list(param.df, AIC.df))
}
param.df <- data.frame() #table with most likely parameters
AIC.df <- data.frame()
for (i in 1:nrow(source)){
tables <- mle_calc(i, source$language[i], source$file[i],param.df,AIC.df)
param.df <- tables[[1]]
AIC.df <- tables[[2]]
}
colnames(param.df) <- c("Language", "lambda", "p", "gamma_1")
colnames(AIC.df) <- c("Language", "1", "2", "3", "4")
param.df
AIC.df
# 1: Introduction
write_table <- function(language,file,lang.df) {
degree_sequence = read.table(file, header = FALSE)
lang.df <- rbind(lang.df,data.frame(language, length(degree_sequence$V1), max(degree_sequence$V1),
sum(degree_sequence$V1)/length(degree_sequence$V1),
length(degree_sequence$V1)/sum(degree_sequence$V1)))
return(lang.df)
}
source = read.table("list_in.txt",
header = TRUE,               # this is to indicate the first line of the file contains the names of the columns instead of the real data
as.is = c("language","file") # this is need to have the cells treated as real strings and not as categorial data.
)
lang.df <- data.frame()
for (x in 1:nrow(source)) {
lang.df <- write_table(source$language[x], source$file[x],lang.df)
}
colnames(lang.df) <- c("Language", "N", "Maximum degree", "M/N", "N/M")
#Table with all languages and some important values
lang.df
# 2: Visualization
# Function to plot the degree sequence of a given language
degree_plot <- function(language,file){
degree_sequence = read.table(file, header = FALSE)
degree_spectrum = table(degree_sequence)
barplot(degree_spectrum, main = language, xlab = "degree", ylab = "number of vertices", log = "y")
}
for (x in 1:nrow(source)){
degree_plot(source$language[x], source$file[x])
}
# 3: Log-likelihood function
require(stats4) # for MLE
require(VGAM) # for the Riemann-zeta function
mle_calc <- function(i,language,file,param.df,AIC.df){
# Geometric distribution
minus_log_like_geo <- function(p){
-(sum(x)-length(x)) * log(1-p) - length(x) * log(p)
}
# Poisson distribution
minus_log_like_pois <- function(lambda){
C <- 0
for (i in 1:length(x)) {
C = C + sum(log(2:x[i]))
}
- sum(x) * log(lambda) + length(x) * (lambda + log(1-exp(1)^(-lambda))) + C
}
# Zeta distribution
minus_log_like_zeta <- function(gamma){
length(x) * log(zeta(gamma)) + gamma * sum(log(x))
}
# Zeta (gamma=2) distribution
minus_log_like_zeta2 <- function(){
mle <- length(x) * log(pi^2/6) + 2 * sum(log(x))
return(mle)
}
# Right-truncated zeta distribution
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
x <- read.table(file, header = FALSE)$V1
mle_geo <- mle(minus_log_like_geo,
start = list(p = lang.df$"N/M"[i]),
method = "L-BFGS-B",
lower = c(0.0000001),
upper = c(0.9999999))
mle_pois <- mle(minus_log_like_pois,
start = list(lambda = lang.df$"M/N"[i]),
method = "L-BFGS-B",
lower = c(1.0000001))
mle_zeta <- mle(minus_log_like_zeta,
start = list(gamma = 2),
method = "L-BFGS-B",
lower = c(1.0000001))
#This gives error for some languages
#mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
#                      start = list(gamma = 2, h_max = max(x)),
#                      method = "L-BFGS-B",
#                      lower = c(1.0000001, 1),
#                      upper = c(Inf, max(x)+1))
# 4: Finding the best models
best_p_geo <- attributes(summary(mle_geo))$coef[1]
best_lambda_pois <- attributes(summary(mle_pois))$coef[1]
best_gamma_zeta <- attributes(summary(mle_zeta))$coef[1]
#best_gamma_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[1]
#best_h_max_zeta_trunc <- attributes(summary(mle_zeta_trunc))$coef[2]
param.df <- rbind(param.df,data.frame(language, best_lambda_pois, best_p_geo, best_gamma_zeta))
# 5: Best model selection
get_AIC <- function(m2logL,K,N){
m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
AIC_list <- c()
AIC_list[1] <- get_AIC(attributes(summary(mle_geo))$m2logL,1,length(x))
AIC_list[2] <- get_AIC(attributes(summary(mle_pois))$m2logL,1,length(x))
AIC_list[3] <- get_AIC(attributes(summary(mle_zeta))$m2logL,1,length(x))
mle_zeta2 <- 2*minus_log_like_zeta2()
AIC_list[4] <- get_AIC(mle_zeta2,0,length(x))
#AIC_zeta_trunc <- get_AIC(attributes(summary(mle_zeta_trunc))$m2logL,2,length(x))
best_AIC <- min(AIC_list)
AIC_list <- AIC_list-best_AIC
AIC.df <- rbind(AIC.df,data.frame(language,t(AIC_list)))
return(list(param.df, AIC.df))
}
param.df <- data.frame() #table with most likely parameters
AIC.df <- data.frame()
for (i in 1:nrow(source)){
tables <- mle_calc(i, source$language[i], source$file[i],param.df,AIC.df)
param.df <- tables[[1]]
AIC.df <- tables[[2]]
}
colnames(param.df) <- c("Language", "lambda", "p", "gamma_1")
colnames(AIC.df) <- c("Language", "1", "2", "3", "4")
param.df
AIC.df
# 5: Best model selection
get_AIC <- function(m2logL,K,N){
m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}
x <- read.table(source$file[1], header = FALSE)$V1
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.0000001, 1),
upper = c(Inf, max(x)+1))
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.0000001, 1),
upper = c(Inf, max(x)+1))
mle_zeta_trunc
x <- read.table(source$file[2], header = FALSE)$V1
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.0000001, 1),
upper = c(Inf, max(x)+1))
mle_zeta_trunc
x <- read.table(source$file[3], header = FALSE)$V1
minus_log_like_zeta_trunc <- function(gamma,h_max){
length(x) * log(sum((1:h_max)^(-gamma))) + gamma * sum(log(x))
}
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.0000001, 1),
upper = c(Inf, max(x)+1))
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.0000001, 10),
upper = c(Inf, max(x)+1))
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.0000001, 100),
upper = c(Inf, max(x)+1))
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.01, 100),
upper = c(Inf, max(x)+1))
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
start = list(gamma = 2, h_max = max(x)),
method = "L-BFGS-B",
lower = c(1.1, 100),
upper = c(Inf, max(x)+1))
lower = c(1.1, 1000,
mle_zeta_trunc <- mle(minus_log_like_zeta_trunc,
mle_zeta_trunc
